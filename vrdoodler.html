 <!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <title>VRDoodler!!!</title>
 
</head>
 <link rel="stylesheet" href="css/style.css">
     <script type="text/javascript" src="http://code.jquery.com/jquery-latest.pack.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.js"></script>
<script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script>
<!--<script src="js/controls/OrbitControls.js"></script>-->
<!--<script src="js/shaders/LineDisplacementShader.js"></script>-->

	<script src="../js/exporters/OBJExporter.js"></script>
	<script src="../js/loaders/OBJLoader.js"></script>



 <script id="vertexShader" type="x-shader/x-vertex">  
      
	varying vec2 vUv;
	uniform float color;
	varying float noise;
	uniform float time;
	
	
	
	
	void main() {
	
		vUv = uv;
	
		// add time to the noise parameters so it's animated
		//noise = 15.0 *  -.10 * turbulence( .2 * normal + time );
		//float b = 2.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 2.0 ) );
		//float displacement = noise/.5;
		//- noise + b;
		//sin(fTimer+Tex.x*10)*0.01f;
		//	float newXPosition = sin(time + position.x * 2.)  ;
		
		gl_Position = projectionMatrix * modelViewMatrix * vec4( position,1.0 );
	
	}
               
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">

    varying vec2 vUv;
	uniform float color;
	void main() {

    // colour is RGBA: u, v, 0, 1
	gl_FragColor = vec4( vec3(color), 1. );

	}
    </script>
    
    <script src="js/shaders/LineDisplacementShader.js"></script>
    
   <h1></h1>
<div class="hero-unit">
	<h2>Advanced Options</h2>
	<ul>
	<li><input id="draw" type="checkbox" value="draw"/><span>d</span>raw</li>
	<li><form><input id="snapTo" type="radio" name="mode" value="snapTo" /><span>s</span>nap To<input id="freehand" type="radio"  name="mode" value="freehand" checked/>freehand </form></li>
	<li>Press <span>Shift</span> to Square Along Grid<select id="toggleCameraPlaneLock" value="0" enabled="false"/>
		<option value="0">None</option>
		<option value="1">vertical Lock</option>
		<option value="2">horizontal Lock</option>
		<option value="3">Both</option>
		</select> 
	
	</li>
	<li><input id="rotateX" type="button" value="rotate90" enabled="false"/><span>r</span>otate 90  Shift-r to set</li>
	
	<li>Line Width
		<select id="width" type="text" value="2" enabled="true"/></li>
		<option value="2">2</option>
		<option value="4">4</option>
		<option value="4">6</option>
		<option value="4">8</option>
		<option value="4">10</option>
		</select> 
		<br/>
	<input id="exportLine" type="button" value="Export" enabled="false"/>
	<br/>
	<input id="grid" type="checkbox" value="toggleGrid" enabled="false"/><span>g</span>rid
	<p>"draw at" orientation keys:<br/>
	shift to draw level<br/>
	shift-g to draw along a fixed vertical<br/>
	ctrl-g to draw at a fixed horizon <br/>
	ctrl-shift to draw straight vertical line<br/>
	alt-g to draw straight horizontal line<br/></p>
	</ul>
	<label id="mousecoords" value="">
	<!--
	<input id="width" type="checkbox" value="lineWidth" enabled="false"/>Line Width
	<input id="trace" type="checkbox" value="trace" enabled="false"/>Trace
	
	<input id="colorToggle" type="checkbox" value="colorToggle" enabled="false"/>Color-->
</div>

<div id="tutorial">
 <h3>Level</h3>
 <input id="instructions" type="button" value="Guide Me"/>
 <select id="level" type="text" value="0" enabled="true"/></li>
		<option value="0">beginner</option>
		<option value="1">intermediate</option>
		<option value="2">advanced</option>	
 </select> 
 <p id="tuteInstructions"></p>
</div>

<div id="infoPanel">
 <h3>Log:</h3>
</div>
    <!--<a id="turnedoffinfoPanelTag" href="#menu" class="gradient-menu"></a>-->
    
    
    <br>
<script>
 
 
 	var camera, scene, renderer,orbitcamera,light;
    var geometry, material, mesh;
    var controls;
 	var context = null;
	var currentPlane = 0;
	var drawnline = [];
	var container, canvas;

	
	var manager;


	var MAX_POINTS = 800;
	var countVertices = 0;
	var sketchContainer,objContainer ;
	var CURRENTspline = -1; //incremented at initNewLine
	var raycaster, parentTransform, planeLockInd, lineLockInd, planeLockOutline, grid ;
	var mouse = new THREE.Vector2();
	var currentIntersected, currentIntersectedPoint, lastIntersected, lastIntersectedPoint;
	var currentMouseRay;
	
	var bIsDrawing = false;
	var bShowInfo = true;
	
	var ORBITMODE = 0;  //when not drawing
	var FREEHANDMODE = 1;  //when drawing
	var SNAPMODE = 0;		//snap to pre-existing line/objects	
	var DRAWMODE = 0;//ORBITMODE;
	var CURRENTLINEWIDTH = 2;
	var PLANEROTATELOCK = 0;//not using..
	var CAMERAPLANELOCK = 0;//not using..
	
	var SNAPPLANETOGRID = 0;
	
	var cameraAngle = 0;
	var pivotRadius = 1;
	var pivotPoint;
	var initCamRotPos =0;
	var squareAngle = 90 * Math.PI/180;
	var plane, planegeo, planemat,planeBoundsMat, planeBounds;
	var PLANEROTATE = 0;
	var COLOR = 0;
	var linematerial = null;
	var start = Date.now();
		var clock = new THREE.Clock();
	var edges, cameraHelp;
	
	var tuteBegPhrases = ["When you are done drawing, press r to rotate to the side view of your drawing",
							"Hover over the previous drawn line to connect your new lines",
							"Now, when you are done drawing, press r to rotate to the back view of your drawing",
							"Hover over the previous drawn line to connect your new lines",
							"Now, when you are done drawing, press r to rotate to the other side view of your drawing",
							"Hover over the previous drawn line to connect your new lines",
							"Press r to return to the front view of your 3D drawing!"];
	var tuteBegCount = 0;
	
	function init(){	
		container = document.createElement( 'div' );
		container.style.position = 'absolute';
		container.style.top = '30px';
		container.style.width = '100%';
		container.style.textAlign = 'center';
		container.style.color = '#fff';
		container.style.fontWeight = 'bold';
		container.style.backgroundColor = 'transparent';
		container.style.zIndex = '1';
		container.style.fontFamily = 'Monospace';
		container.innerHTML = "draw1";
		document.body.appendChild( container );

	
		scene = new THREE.Scene();

    	scene.add( new THREE.AxisHelper(500) );  
    	
    	
    	light = new THREE.DirectionalLight( 0xffffff );
				scene.add( light );
    	renderer = new THREE.WebGLRenderer( { antialias: false } );		
		renderer.setSize( window.innerWidth, window.innerHeight );
		
		container.appendChild( renderer.domElement );
	
		camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.set(1, 1, 1);
		camera.name="orig";




			   		   
		sketchContainer = new THREE.Object3D();  //helpers etc that aren't included in raycasting
		objContainer = new THREE.Object3D();
		objContainer.name = "objContainer";
		objContainer.geometry = null;

  		scene.add(objContainer);
  		scene.add(sketchContainer);
		controls = new THREE.OrbitControls( camera, renderer.domElement );
		//controls.addEventListener( 'change', render ); not needed b/c I have an animate loop
		
	
  		
  		raycaster = new THREE.Raycaster();
		raycaster.linePrecision = .05;
		
		var geometry = new THREE.SphereGeometry( .05 );
		var material = new THREE.MeshBasicMaterial( { color: 0xee0055 } );
		lineLockInd = new THREE.Mesh( geometry, material );
		lineLockInd.visible = false;
		scene.add( lineLockInd );
		
		geometry = new THREE.SphereGeometry( .1 );
		material = new THREE.MeshBasicMaterial( { color: 0x003333 } );
		planeLockInd = new THREE.Mesh( geometry, material );
		planeLockInd.visible = false;
		//scene.add( planeLockInd );
		

		
		planegeo = new THREE.PlaneGeometry(.5,.5);
		planemat = new THREE.MeshBasicMaterial( {color: 0xddcccc, side: THREE.DoubleSide, transparent:true, opacity:.4} );
		planeBoundsMat = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide, transparent:true, opacity:.4} );
		planeBoundsMat2 = new THREE.MeshBasicMaterial( {color: 0x00ff00, side: THREE.DoubleSide, transparent:true, opacity:.4} );


		lastIntersectedPoint = new THREE.Vector3(0,0,0);		


		window.addEventListener('resize', onWindowResize, false);
		document.addEventListener('mousedown', onSketchMouseDown, false);
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		
    	document.getElementById('level').onchange = setTutorialLevel;
		
		document.getElementById('draw').onclick = toggleDrawMode;
		document.getElementById('snapTo').onclick = snapTo;
		document.getElementById('freehand').onclick = snapTo;
		document.getElementById('exportLine').onclick = exportToObj;
		document.getElementById('width').onchange = setCurrentLineWidth;
		document.getElementById('grid').onclick = toggleGrid;
		document.getElementById('toggleCameraPlaneLock').onchange=toggleCameraPlaneLock;
		document.getElementById('rotateX').onclick = rotateX;
;
		/*document.getElementById('show').onclick = printVerts;

		
		document.getElementById('trace').onclick = trace;

		document.getElementById('colorToggle').onclick = colorToggle;*/
		
		//get prefs but for now
		setTutorialLevel(0);
		
        var light = new THREE.DirectionalLight( 0xcccccc, 1 );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );
			
            
        document.addEventListener( 'keydown', onVRDoodlerKeyDown, false );
		 document.addEventListener( 'keyup', onVRDoodlerKeyUp, false );
		manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {
				console.log( item, loaded, total );

		};
	
		$('#infoPanelTag').click(function() {
		  $("#infoPanel").toggle( "slow" );		  
		});
		
		$('input').click(function() {
		 $("#infoPanel").text("Draw Mode is " + DRAWMODE + " Line Width is " + CURRENTLINEWIDTH + " Snap Mode is " + (SNAPMODE) );

 
	  });
	  
	  
	   //scene.add(camera);
 
	//loadAnObject();
	}
	
	

	var saveFileLocally = (function () {
		var a = document.createElement("a");
		document.body.appendChild(a);
		a.style = "display: none";
		return function (data, fileName) {
			var json = JSON.stringify(data),
				blob = new Blob([json], {type: "octet/stream"}),
				url = window.URL.createObjectURL(blob);
			a.href = url;
			a.download = fileName;
			a.click();
			window.URL.revokeObjectURL(url);
		};
	}());



	function exportToObj ()
			{
				var exporter = new THREE.OBJExporter();
				var result = exporter.parse(scene);  /*not exporting right?? only exports as mesh and buffer geometry*/
				
				saveFileLocally(result, "myDrawing.obj");
				
				var xmlhttp = new XMLHttpRequest();
				xmlhttp.open("POST", "http://localhost:8080/writeObj", true);
				xmlhttp.onreadystatechange = function () {
				  if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {
					//Handle response
				  }
				};
				 xmlhttp.send(result);
				
	}
	function importScene(){
			/* something like this */
			var loader = new THREE.OBJLoader( manager );
				loader.load( '../test.obj', function ( object ) {

					object.traverse( function ( child ) {
						
						if ( child.children instanceof Array ) { //THREE.Line
						
							child.children.every( function ( gchild ){
								if ( gchild instanceof THREE.Mesh ) { //THREE.Line
									initNewLine(null, null, gchild.geometry, gchild.geometry.attributes.position);
								}
							});

						}

					 });

					object.position.y = - 80;//?
					scene.add( object );

				}, onProgress, onError );
			
	}


	var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};

	var onError = function ( xhr ) {
	};

	/*make it easier for user to draw on standard rotation*/
	function rotateX(){
 		
		camera.lookAt(lastIntersectedPoint);
 		camera.rotation.x += 90 * Math.PI / 180;
 		
		
	}
	function rotateY(){
 	
 		planeBounds.rotation.y += 90 * Math.PI / 180;
 		
		
	}
	function rotateZ(){
 
 		planeBounds.rotation.z += 90 * Math.PI / 180
 		
		
	}
	
	function setPivotPoint(pt){
		if (pivotPoint != 0){
			pivotPoint = pt;
			pivotRadius = camera.position.distanceTo(pivotPoint);
		}
		
	}
	

	function cameraInitRotPos(camPos){
		if (!initCamRotPos){
			initCamRotPos = camPos?camPos:camera.position;	
			cameraAngle = Math.atan(camera.position.z/camera.position.x);
		}	
		
		return initCamRotPos;
	}
	
	
	function horizontalRotation(angle){

		setPivotPoint(currentIntersectedPoint?currentIntersectedPoint:lastIntersectedPoint);
		cameraInitRotPos();
			
		cameraAngle-=angle?angle:squareAngle; //later when a user can specify degree of rotation
		cameraInitRotPos();
		
  		camera.position.x =  pivotPoint.x +  Math.cos(cameraAngle) * pivotRadius;
  		camera.position.z = pivotPoint.z +  Math.sin(cameraAngle) * pivotRadius;
  		

  		controls.target =pivotPoint;
		camera.target = pivotPoint;
		camera.lookAt(pivotPoint);
		
		if (SNAPPLANETOGRID){
			planeLockOutline.lookAt(camera.position);
		}
		
    
} 

	

	function togglePlaneRotateLock(){
		PLANEROTATELOCK =PLANEROTATELOCK?0:1;	
		 return PLANEROTATELOCK;
	}
	
	
	function setTutorialLevel(e){
	
		var level;
		if (typeof e == "object")
			level = e.currentTarget.value;
		else
			level = e;
	//return functionality at desired level
	//like, can orbit camera?
	//turn off grid?
	//draw at plane vs snapped plane?
		
		/*let user draw on plane. rotate at pivotpoint(lastintersected or currentIntersected), 
			turn grid ray off, let user hover over line to draw off of
		*/
			if (level == "0"){ //beginner
				snapPlane(0);
				camera.position.x = 0;
				camera.position.z = 5;
				camera.position.y = .5;
				//lastIntersectedPoint = new THREE.Vector3(0,0,1); 
				plane = makePlanes(planemat,lastIntersectedPoint ,"guide", plane);
				
				snapPlane(1); //this will fix the camera position and keep the plane where it is
				setDrawMode(true);
				setSnapMode(true); //need this to properly pivot for rotation.
				changeControls(false);
				
				camera.lookAt(lastIntersectedPoint);
				//if (!grid) setupGrid();
				//grid.visible = true;
				document.getElementById("tuteInstructions").innerHTML = tuteBegPhrases[tuteBegCount++];
				$(".hero-unit").css("visibility","hidden");
			}else if (level =="1"){
				setDrawMode(false);//allow user to set camera orbit
				setSnapMode(true);
				SNAPPLANETOGRID = 1;
				if (!grid) setupGrid();
				grid.visible = true;
				
			}else if (level ==2){ //advanced
				setDrawMode(false);//allow user to set camera orbit
				setSnapMode(true);
					snapPlane(0);
				$(".hero-unit").css("visibility","visible");
				if (!grid) setupGrid();
				grid.visible = true;
				//take off all restraints
				//don't set draw mode, snap or grid, etc
			}
			
		
	
	
	}


	function getCurrentLineWidth(){
		return CURRENTLINEWIDTH;
	}
	
	
	/*will eventually offer black on white or white on black (default) */
	function colorToggle(){
		//TODO need to change background color in tandem...
		COLOR = COLOR?0:1;
		return COLOR;
	}
	
	/* not yet implemented */
	function toggleInfoPanel(){
		//controls.stop();
		bShowInfo = bShowInfo?0:1;
		return bShowInfo;
	}
	function setupGrid(){
		grid = new THREE.GridHelper( 20, .5 );
		grid.name="grid";
		grid.setColors( 0x0000ff, 0x808080 );
		grid.position.y = 0;
		grid.visible = true;
		objContainer.add( grid );
	}
	function toggleGrid(){
	
		if (grid){
			grid.visible = grid.visible?false:true;
		}else{
			setupGrid();
		}
		$("#grid").prop("checked",grid.visible);
	}


	function setCurrentLineWidth(){

	//controls.stop();
		CURRENTLINEWIDTH = document.getElementById("width").value;			
		return CURRENTLINEWIDTH;
	}
	
	//maybe plus/minus 2?
	function toggleCurrentLineWidth(){
		//controls.stop();
		CURRENTLINEWIDTH = CURRENTLINEWIDTH--;			
		return CURRENTLINEWIDTH;
	}
	
	function changeControls(resetCam){
	 	var prevCamera = camera;

		
		if (resetCam){
			camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.name="new";
		
			camera.position.copy( prevCamera.position );
			camera.rotation.copy( prevCamera.rotation );
		}
		

		if (!DRAWMODE){
			controls.enabled = true;
			controls.object = camera;
			
			
		}else{ //if EXTRUDEMODE  //acutally suggesting a flow draw...
			controls.object = camera;
			controls.enabled = false;
		}
		controls.target = lastIntersectedPoint;
		camera.lookAt(lastIntersectedPoint);
	
		camera.updateProjectionMatrix();

	}
	
	function setSnapMode(onoroff){
		SNAPMODE = onoroff;
		$("#snapTo").prop("checked",SNAPMODE);
 		$("#infoPanel").text("Draw Mode is " + DRAWMODE + " Line Width is " + CURRENTLINEWIDTH + " Snap Mode is " + (SNAPMODE));
		
		return SNAPMODE;
	}
	
	function snapTo(){
	
		if (SNAPMODE){
			scene.remove(plane);
			scene.remove(planeLockOutline);
			$("#freehand").prop("checked",true);
			lineLockInd.visible = false;
			}
		else{
			
			$('html,body').css('cursor','crosshair');
		}
		
 		SNAPMODE = SNAPMODE?setSnapMode(0):setSnapMode(1);
 		changeControls(true);
 		//if (SNAPMODE) plane.visible = true; else plane.visible = false;
 		
 		return SNAPMODE;
	}
	
	
	function snapPlanesToLocal(keepOrientation){
	
		var cameraclone = camera.clone();
		cameraclone.position.y = 0;
	
		if (plane){
			plane.rotation.x= 0;
			plane.rotation.z= 0;
	
			planeLockOutline.rotation.x = 0;
			planeLockOutline.rotation.z = 0;
			
			if (!keepOrientation){
				plane.rotation.y= 0;
				planeLockOutline.rotation.y = 0;
			}
			
			if (planeBounds){//not currently used
				planeBounds.rotation.z = 0;
				planeBounds.rotation.x = 0;
			}
		}
		//planeLockOutline.rotation.z = 0;
	}
	
	function setDrawMode(onoroff){
	 	DRAWMODE = onoroff;
	 	$("#draw").prop("checked",DRAWMODE);
	 	$("#infoPanel").text("Draw Mode is " + DRAWMODE + " Line Width is " + CURRENTLINEWIDTH + " Snap Mode is " + (SNAPMODE));
		console.log("draw mode is " + DRAWMODE);
	
		if (DRAWMODE)
        	$('html,body').css('cursor','pointer');
        else 
        	$('html,body').css('cursor','move');
        	
        return DRAWMODE;
	}
	
	
/* if draw, mouse draws (snapping or not). if false, mouse moves camera */
	function toggleDrawMode(){
       
		DRAWMODE = DRAWMODE?setDrawMode(0):setDrawMode(1);       
		changeControls(true);
		
    	return DRAWMODE;
	}
	
	
	

	function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
	}
	
	
	function loadAnObject(){
		var loader = new THREE.JSONLoader( manager );
		var path = "assets/chairVert.json"; //callback needs real var I guess
		var pos = new THREE.Vector3(0,0,10);
		loader.load(path , function ( geo ) {

		var material = new THREE.MeshLambertMaterial({
			//map: THREE.ImageUtils.loadTexture(path+ currentConfig.objTex),  // specify and load the texture
			color:0xff00ff,
			side:THREE.DoubleSide
		  });
			
		var object = new THREE.Mesh(geo, material);
		object.position.x = pos.x;
		object.position.y = pos.y;
		object.position.z = pos.z;
		//object.scale.set(5,5,5);
		
		object.userData.name = "chair";		
		objContainer.add( object );
		});
	
	}




	function onDocumentMouseMove( evt ) {

		evt.preventDefault();
		var mouseQuotient = evt.clientX / window.innerWidth;  //.0 to .9
		mouse.x = ( evt.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( (evt.clientY- container.offsetTop)/ window.innerHeight ) * 2 + 1;
		
		//console.log("mouse.x " + mouse.x + " and y " + mouse.y + " ");
		if (PLANEROTATE){
			var whichz = currentIntersectedPoint? currentIntersectedPoint.z: lastIntersectedPoint.z;
			var degToRotate = Math.round((mouseQuotient * 10)%90);
			console.log( "degToRotate " + degToRotate);
			//plane.rotateY((degToRotate * 90)* Math.PI/180);  //(Math.cos(mouse.x) * 100)/90;
			plane.lookAt(camera.position);
			
		}
		
	}
	
	function snapPlane(mode, keepOrientation){
		SNAPPLANETOGRID = mode;  
        $("#infoPanel").text("SNAPPLANETOGRID ON:" + SNAPPLANETOGRID);
        snapPlanesToLocal(keepOrientation); 
	
	}
			
	function onVRDoodlerKeyDown(evt) {

                switch (evt.keyCode) {

                   case 68: //d draw mode
                   		toggleDrawMode();
                   		
		 					  	
                   break;
                    case 65: // a for axis
                    
                        PLANEROTATE = PLANEROTATE?0:1;
                        edges.update();
                  
                        break;
                        
                        
                     case 16: //shift to snap the plane to square alignment
                    	SNAPPLANETOGRID =1;
                   	  	snapPlane(1, true);  //keep orientation
                   	break;
                    case 71: // g for grid,  make plane 'snapped' to grid, so to speak
                    
                      
                       if (evt.shiftKey && evt.ctrlKey){  //d
                   			//will draw straight horizontal line parallel to x axis
                   			snapPlane(4);
              
                   		}else if (evt.shiftKey && evt.altKey){
                   		
                   			snapPlane(5); 
                   			planeLockOutline.rotation.z = squareAngle;
                   		
                   		}else if (evt.altKey){
                   		
                   			snapPlane(6); 
                   			planeLockOutline.rotation.z = squareAngle;
                   		
                   		}else if (evt.shiftKey){
							//draws at fixed 'squared' plane  No x, y z rotation	
                   			snapPlane(2);  
                   			
                   		}else if (evt.ctrlKey){
                   			//Draw at fixed y with x.rotation = 90 degrees
                   		
                   			snapPlane(3);  
                   			plane.rotation.x = squareAngle;
                   			planeLockOutline.rotation.x = squareAngle;
                   			
                   		}else {
                   			toggleGrid();
                   		}
                   		
                  
                        break;
                        
                        
                     case 82: //r for rotate panel 90
						if (evt.shiftKey){
						  //setCameraInitRotPos(camera.position);
						  setPivotPoint(currentIntersectedPoint?currentIntersectedPoint:lastIntersectedPoint);
						  initCameraRotPos = 0;
						}
						horizontalRotation();
							
						break;
                    case 83: //snap to s	
						snapTo();
						break;
					/* case 80: //p audio
                    	if (CURRENTCOLLISION){
                    		if(CURRENTCOLLISION.userData.audio)
                    			loadProximalSound(CURRENTCOLLISION.userData.configOrder);
                    	
                    	}
                     */ 
    
                    break;
                    
                    
                  
                     
                   case 90: //control-z to erase last
                   	if (evt.ctrlKey)
                   		if (currentDrawnLine()){
                   			
                   			currentDrawnLine().geometry.attributes.position.array = [];
                   			drawnline.pop(CURRENTspline);
                   			--CURRENTspline;
                   		}
                   	break;
               
                }
            }
     function onVRDoodlerKeyUp(evt) {
      		switch (evt.keyCode) {
      			case 71: //shift to erase last
                   	
                   		//make plane 'snapped' to grid, so to speak
                   		SNAPPLANETOGRID = false;
                   	     $("#infoPanel").text("SNAPPLANETOGRID OFF");	
                   	break;
                   	
                   	case 16: //shift 
                   	  SNAPPLANETOGRID =false;
                   	   $("#infoPanel").text("SNAPPLANETOGRID OFF");	
                   	break;
            }
     }
     /* with camera position and the object with which we want to align our next line, transform
     where the projection thinks the mouse is to where we want it to be */
     
	function transformMouseToDesiredPlaneOfInterest(mv, desiredPOI){
			var whichCamera;
	
			var cameraclone = camera.clone();
			var unprojectedMouse = mv.clone().unproject( cameraclone );
			var destpos= cameraclone.position.clone(); 
			var camPos = cameraclone.position.clone(); 
			
			var planeclone = plane.clone();
			var camPlaneDiff = desiredPOI.clone().sub(camPos).normalize();  //if raycasting at plane, this should get correct distance
			
			var dir = unprojectedMouse.sub( camPos ).normalize();
			
			destpos.add(camPlaneDiff.multiplyScalar(desiredPOI.distanceTo(camPos)));
		
		
			if (destpos == desiredPOI){
			//	destpos = mv.clone();
			}
		
			return destpos;
			
				
						
			/* fyi
			this Stack Overflow answer  did not work for me re: z differences.  the distanceTo made it work	
			var dir = unprojectedMouse.sub( camera.position ).normalize();
			var distance = (-currentIntersectedPoint.z- camera.position.z) / dir.z;
			var pos = unprojectedMouse.clone().add( dir.multiplyScalar( distance ) );*/
	
	
	}
			

/* if draw mode, add new vertex to line as mouse moves */
    function onSketchMouseMove(evt) {
    
    	//var whatZ = .5;
        if(renderer) {
          
           	mouse.x = ( evt.clientX / window.innerWidth ) * 2 - 1;
  			mouse.y =  - ( (evt.clientY- container.offsetTop) / window.innerHeight ) * 2 + 1;
                
            var vNow = new THREE.Vector3();
            vNow.set(
					mouse.x,
					mouse.y,
					0.5 );
            
            if(DRAWMODE){
            	if (SNAPMODE){  /*TODO add ability to draw between two planes...*/
            	
            		if (plane.position !== undefined ){  //plane-of-interest better be valid
          		
            			var snapToThis = currentIntersectedPoint;
						if (!currentIntersectedPoint)  //intersection is at plane b/c we are drawing and raytracer is interacting w/ plane
							snapToThis = lastIntersectedPoint;
						var projectedMouse = new THREE.Vector3();
						projectedMouse.set(vNow.x, vNow.y, 0.5 );				
											
						
						unprojectedAndTransformedMouse = transformMouseToDesiredPlaneOfInterest(projectedMouse, snapToThis);
						
						if (SNAPPLANETOGRID ==4){//draws straight horizontal line parallel to x axis
            				unprojectedAndTransformedMouse.x = plane.position.x;
            				unprojectedAndTransformedMouse.z = plane.position.z;
            			}
            			else if (SNAPPLANETOGRID ==5){//draws straight vertical line parallel to y axis
            				unprojectedAndTransformedMouse.y = plane.position.y;
            				unprojectedAndTransformedMouse.z = plane.position.z;
            			}else if (SNAPPLANETOGRID ==6){//draws straight horizontal line parallel to z axis
            				unprojectedAndTransformedMouse.y = snapToThis.y;
            				unprojectedAndTransformedMouse.x = snapToThis.x;
            			}
						updateLineBuffer(unprojectedAndTransformedMouse);
						//currentLine().push(unprojectedAndTransformedMouse); 
						
						
					}else { 
						console.log("hmm plane not defined");
					}
            	}else { //freehand

            		vNow.unproject(camera);
            		console.log("drawing at plane vNow " +  vNow.x+ " " +vNow.y);
            		
            		updateLineBuffer(vNow); 
           		}
				 //vNow.z = 0;
        		
        		//push subsequent vertices into master line array
        	
            }          
        }
        else{
        console.log("renderer null");}
    }
    
        
    
	function currentDrawnLine(){
		return drawnline[CURRENTspline];
	}

    		    
    
    /* after initing new line
    */
    function onSketchMouseUp(evt) {
    	document.removeEventListener("mousemove",onSketchMouseMove,false);
  	
    	if (DRAWMODE){
    	
			bIsDrawing=false;
			
			//now that we are done drawing, trim drawn array to number of master line's vertices 
    		var positions = currentDrawnLine().geometry.attributes.position.array;
    		currentDrawnLine().geometry.attributes.position.array = positions.slice(0, (countVertices-1) *3);
    				
    		currentIntersected = undefined;
			currentIntersectedPoint = undefined			
    	
    		console.log("current is " + CURRENTspline);
    		}        
    }
   
	


	function initDrawnLine(geometry, positions,mv){
		

		if (!geometry){  //freehand or snap, doesn't matter, init the line
			geometry = new THREE.BufferGeometry();
			positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point
			countVertices = 0;
			if (mv){
				positions[0] = mv.x;
				positions[1] = mv.y;
				positions[2] = mv.z;
				countVertices = 1;
			}
			geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	
			geometry.setDrawRange( 0, 0 );	
			

		
		}else{ //loaded from OBJ file
			
			geometry.addAttribute( 'position', positions )
			geometry.setDrawRange( 0, geometry.attributes.position.length-1 );
		}
	
		
		linematerial = new THREE.LineBasicMaterial( { color: COLOR?0x000000:0xffffff, linewidth: getCurrentLineWidth(),smoothing:1 } );
	    //linematerial = new THREE.ShaderMaterial(THREE.LineDisplacementShader); 
	    linematerial.linewidth = CURRENTLINEWIDTH;
		
		drawnline[CURRENTspline] = new THREE.Line( geometry,  linematerial ); //to store line	
		currentDrawnLine().geometry.attributes.position.needsUpdate = true; 
	
	}
	
 function updateLineBuffer(newvec) {
		if (currentDrawnLine()){
		
			//get array and update it with the new line vertices
			var positions = currentDrawnLine().geometry.attributes.position.array; //has one vertex to begin with
			
			var index = countVertices *3 ;
			
			if (newvec){
				positions[index ++] = newvec.x;
				positions[index ++] =newvec.y;
				positions[index ++] =newvec.z;
			}
			//what is better, to initialize float32array with a set of vertices (which I don't know yet), or to add to it like this?
			currentDrawnLine().geometry.attributes.position.needsUpdate = true; // required after the first render
			
			countVertices++;
		}
	}
	
	

	
	
	//called from mouseDown
	//works for importing from file or if using mouse to start line
	function initNewLine(mouseVec, bUnproject, geo,positions){
	
		CURRENTspline++;
		
		if (!geo){
			 var vNow = new THREE.Vector3(mouseVec.x, mouseVec.y, mouseVec.z);
			 if (bUnproject)
				vNow.unproject(camera);
		
			initDrawnLine(null, null, vNow);

		}else //from import
		 	initDrawnLine(geo, positions);
		
		objContainer.add( currentDrawnLine() );  
	
	}

    
     function onSketchMouseDown(evt) {
     
   		if(evt.which == 3) return;      	
    	if (evt.target.nodeName == 'CANVAS'){
          	
          	mouse.x = ( evt.clientX / window.innerWidth ) * 2 - 1;
  			mouse.y =  - ( (evt.clientY- container.offsetTop)/ window.innerHeight ) * 2 + 1;
       		var mouseVec = new THREE.Vector3(mouse.x, mouse.y, 0.5);
			if (DRAWMODE > ORBITMODE){
			
				bIsDrawing=true;
				
				if (SNAPMODE ){ /*originate line according to intersected object. 	
								  either grid or previously drawn line via plane-of-interest*/
				
					
						initNewLine(currentIntersectedPoint , false);
						console.log("drawing at plane lock intersection " + currentIntersectedPoint.x + " " + currentIntersectedPoint.y + " " + currentIntersectedPoint.z );

				}else { 

						//mouseVec.applyMatrix4(plane.matrixWorld);
						initNewLine(mouseVec, true);
						//console.log("drawing at .5");
					
				} 
			
				//set up for drawing line
				document.addEventListener("mousemove",onSketchMouseMove,false);
				document.addEventListener("mouseup",onSketchMouseUp,false);
				
				
			}
        }
    }
    
    
// animate
	function printVerts(){		
		
	}
	
	function getInverseViewMatrix()
{
	var testMat = plane.matrix.clone();
    var inverseCamToSrc = new THREE.Matrix4().getInverse(camera.matrixWorld);
    inverseCamToSrc.multiply(testMat);
  	return inverseCamToSrc;
  
}
	
	
	function makeDrawingPlane(planePos, name){
			var outlineMaterial2 = new THREE.MeshBasicMaterial( { color: 0x00eeee, transparent:true, opacity:.2,side: THREE.DoubleSide } );

			planeLockOutline = new THREE.Mesh( planegeo, outlineMaterial2 );
			planeLockOutline.scale.multiplyScalar(10); //should calc viewport size...
			planeLockOutline.position.copy(planePos);
			var dir = planePos.clone().sub( camera.position ).normalize();
			planeLockOutline.position.add(dir.multiplyScalar(.005));					
			
			planeLockOutline.lookAt(camera.position);
			planeLockOutline.visible = true;
			planeLockOutline.name = name;
			
			scene.add(planeLockOutline);
			
			return planeLockOutline;
	
	
	
	}
/* the little plane indicates location and direction
   the outline plane is the canvas/plane on which to draw... I guess it could be a vertical grid
*/
	function makePlanes(material, vecPlane, name, planeObj){

		 planeObj = new THREE.Mesh( planegeo, material );
		 planeObj.position.set( 0, 0, 0 );
		 planeObj.name = name;
		 planeObj.position.copy(vecPlane);

		 scene.add( planeObj );
		 planeObj.lookAt(camera.position);
		 
		 if (!isDrawingPlaneLocked()){
		 	planeLockOutline = makeDrawingPlane(planeObj.position, name);
		 }	
		
		
		

		//edges = new THREE.FaceNormalsHelper( plane, 1, 0x00ff00, 1 );
		//scene.add(edges);
		
		return planeObj;
	}
	
	
		/*given what the user is doing, disallow plane from moving*/
	function isDrawingPlaneLocked(){
	
		/*if set, we need the plane to stay fixed in place according to framing
		   therefore, do not change plane, but allow raytracing 
		*/
		if (SNAPPLANETOGRID){
			return true;	
		}
		return false;
	
	
	
	}	/*given what the user is doing, disallow ray intersection to change*/
	function ignoreGridRays(){
	
		/*if set, we need the currentIntersectedPoint to stay fixed in place according to framing
		   therefore, do not change point
		*/
		if (SNAPMODE && SNAPPLANETOGRID && !bIsDrawing ){
			return true;	
		}
		return false;
	
	}
		
	function makePhotoSphere( photo, w, d){
	
	}
	
	
	/*function makeCube( w,h,d){
			var mesh;
			var planeGeo = new THREE.BoxGeometry(w,h,d);				
			mesh = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({color:0x000fff, side:THREE.DoubleSide}));
			mesh.position.x = 5;
			mesh.position.y = 1;
			mesh.position.z = 3;
			sketchContainer.add(mesh);
					
			}
*/


	/* highlight selected line, add plane to indicate direction of new to-be-attached line */
	//shader code currently commented out...
	//maybe be able to select line and make thicker or thinner (nice to have...)

	function handleRayIntersections(intersects){
	
		if ( intersects.length > 0 ) {
		
				if ( currentIntersected !== undefined ) {
					//currentIntersected.material.linewidth = CURRENTLINEWIDTH;
					//currentIntersected.material.color.setRGB(200,200,200);
				}
				
				
					currentIntersected = intersects[ 0 ].object;
					
					if(currentIntersected.name == 'grid' && ignoreGridRays()){
						if (intersects[1])
							currentIntersected = intersects[ 1 ].object;
						else{
							currentIntersected = undefined;
							currentIntersectedPoint = undefined;
							lineLockInd.visible = false;
							return;
						}
					
					}else if (currentIntersected.name == 'grid')
						lineLockInd.material.color.set(0xffffcc);
					

					currentIntersectedPoint= intersects[ 0 ].point;  //sorted in desc. order, not really accurate for mouse hover FYI 
					
					lastIntersected = currentIntersected;
					lastIntersectedPoint = currentIntersectedPoint;
					
					
						
					
					//don't refresh the plane if we are snapping/locking/drawing to/on it
				
					if (!isDrawingPlaneLocked()){
						scene.remove(plane); 
						scene.remove(planeLockOutline);
						plane = makePlanes(planemat, currentIntersectedPoint,"guide", plane);	
									
					}
	console.log("plane pos " + plane.position.x + " " + plane.position.y + " "+ plane.position.z + " ");
					
					lineLockInd.position.copy(currentIntersectedPoint);
					lineLockInd.visible = true;
					
					/*for use with shaders
					for( var i = 0; i < intersects.length; i++ ) {
						var intersection = intersects[ i ],
						obj = intersection.object;
	
						//obj.material.color.setRGB( 100,10,10);//1.0 - i / intersects.length, 0, 0 );
						//obj.material.uniforms.color.value = 1.0;
					}*/
				
				
		
		} else {
				//reset
				if ( currentIntersected !== undefined ) {
					//currentIntersected.material.linewidth = CURRENTLINEWIDTH;
					//currentIntersected.material.color.setRGB(250,250,250);
					//currentIntersected.material.uniforms.color.value = 1.0;
				}
				
				currentIntersected = undefined;
				currentIntersectedPoint = undefined;
				lineLockInd.visible = false;
				
		}
	
	}

	function animate() {

		requestAnimationFrame(animate);

	
		if (currentDrawnLine()) {//make sure initialized
			currentDrawnLine().geometry.setDrawRange( 0, countVertices-1 );				
		}
		camera.updateMatrixWorld();
		camera.updateProjectionMatrix();

			
		raycaster.setFromCamera( mouse, camera );//setFromCamera unprojects mouse vector  ////LOOK HERE  //negate and see what happens  //check orbit
		var intersects = raycaster.intersectObjects( objContainer.children, true);
		
		if (DRAWMODE && SNAPMODE &&!bIsDrawing){
			lineLockInd.material.color.set(0xff0000);
			handleRayIntersections(intersects);
			
		}else if (DRAWMODE && SNAPMODE && bIsDrawing){
			lineLockInd.material.color.set(0x00ff00);
			var intersects = raycaster.intersectObjects([planeLockOutline], true);
			handleRayIntersections(intersects);
		}
		//ability to draw while moving plane backwards or forwards
		
		
		//if (linematerial) linematerial.uniforms[ 'time' ].value = .000025 * ( Date.now() - start );
		render();	 
		  
		if (!DRAWMODE){
			//controls.update(clock.getDelta());
		}
		
	
	   } 
	   
	function render() {
  			renderer.render( scene, camera );
		}
		
	init();
	//cameraHelp = new THREE.CameraHelper(camera);
	//scene.add(cameraHelp);
	animate();
	
</script>
</html>